import '../../features/finance/data/models/transaction_model.dart';
import '../../features/finance/data/repositories/transaction_repository.dart';
import 'logger_service.dart';

class FinanceService {
  final TransactionRepository _repository;

  FinanceService(this._repository);

  /// Main method to create a transaction
  Future<TransactionModel> createTransaction({
    required String description,
    required double amount,
    required TransactionType type,
    String? category,
    String? referenceNumber,
    String? paidBy,
    String? paidTo,
    TransactionSource? source,
    String? sourceId,
    DateTime? transactionDate,
  }) async {
    try {
      final transaction = TransactionModel(
        id: '', // Will be generated by database
        description: description,
        amount: amount,
        type: type,
        category: category,
        createdAt: transactionDate ?? DateTime.now(),
        referenceNumber: referenceNumber,
        paidBy: paidBy,
        paidTo: paidTo,
        source: source,
        sourceId: sourceId,
      );

      final created = await _repository.createTransaction(transaction);
      LoggerService.info('Transaction created: ${created.id} - $description');
      return created;
    } catch (e) {
      LoggerService.error('Error creating transaction: $description', e);
      rethrow;
    }
  }

  /// Create credit transaction for maintenance payment
  Future<TransactionModel> createMaintenanceCredit({
    required String paymentId,
    required String flatNumber,
    required String residentName,
    required double amount,
    required int month,
    required int year,
    String? residentId,
  }) async {
    final monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    final monthName = monthNames[month - 1];

    return createTransaction(
      description: 'Maintenance Payment - Flat $flatNumber - $monthName $year',
      amount: amount,
      type: TransactionType.credit,
      category: 'maintenance',
      referenceNumber: paymentId,
      paidBy: residentId,
      source: TransactionSource.maintenance,
      sourceId: paymentId,
    );
  }

  /// Create debit transaction for vendor invoice payment
  Future<TransactionModel> createVendorDebit({
    required String invoiceId,
    required String vendorName,
    required String vendorId,
    required double amount,
    String? invoiceNumber,
  }) async {
    final invoiceRef = invoiceNumber ?? invoiceId;
    return createTransaction(
      description: 'Vendor Payment - $vendorName - Invoice $invoiceRef',
      amount: amount,
      type: TransactionType.debit,
      category: 'vendor',
      referenceNumber: invoiceId,
      paidTo: vendorId,
      source: TransactionSource.vendor,
      sourceId: invoiceId,
    );
  }

  /// Create credit transaction for deposit collection
  Future<TransactionModel> createDepositCredit({
    required String depositId,
    required String flatNumber,
    required double amount,
    String? residentId,
  }) async {
    return createTransaction(
      description: 'Deposit on Renovation - Flat $flatNumber',
      amount: amount,
      type: TransactionType.credit,
      category: 'deposit',
      referenceNumber: depositId,
      paidBy: residentId,
      source: TransactionSource.deposit,
      sourceId: depositId,
    );
  }

  /// Create debit transaction for deposit refund
  Future<TransactionModel> createDepositRefund({
    required String depositId,
    required String flatNumber,
    required double amount,
    String? residentId,
  }) async {
    return createTransaction(
      description: 'Deposit Refund - Flat $flatNumber',
      amount: amount,
      type: TransactionType.debit,
      category: 'deposit_refund',
      referenceNumber: depositId,
      paidBy: residentId,
      source: TransactionSource.deposit,
      sourceId: depositId,
    );
  }

  /// Create credit transaction for society room charge
  Future<TransactionModel> createRoomCharge({
    required String roomId,
    required String roomNumber,
    required double amount,
    required int month,
    required int year,
  }) async {
    final monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    final monthName = monthNames[month - 1];

    return createTransaction(
      description: 'Room Charge - $roomNumber - $monthName $year',
      amount: amount,
      type: TransactionType.credit,
      category: 'room_charge',
      referenceNumber: roomId,
      source: TransactionSource.roomCharge,
      sourceId: roomId,
    );
  }

  /// Check if transaction already exists for a source
  Future<bool> transactionExists({
    required TransactionSource source,
    required String sourceId,
  }) async {
    try {
      final transactions = await _repository.getTransactions();
      return transactions.any((t) => 
        t.source == source && t.sourceId == sourceId
      );
    } catch (e) {
      LoggerService.warning('Error checking transaction existence: $e');
      return false;
    }
  }
}

